# 技术要点

[TOC]



## 一、多模块开发

| **序号** | **名称**     | **说明**                                                     |
| -------- | ------------ | ------------------------------------------------------------ |
| 1        | sky-take-out | maven父工程，统一管理依赖版本，聚合其他子模块                |
| 2        | sky-common   | 子模块，存放公共类，例如：工具类、常量类、异常类等           |
| 3        | sky-pojo     | 子模块，存放实体类、VO、DTO等                                |
| 4        | sky-server   | 子模块，后端服务，存放配置文件、Controller、Service、Mapper等 |

### 1，父子工程maven的设置

sky-take-out作为父模块一般只在开发时管理整个项目，而不单独打包。

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.sky</groupId>
    <artifactId>sky-take-out</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>pom</packaging>
	
    <modules>
        <module>sky-common</module>
        <module>sky-pojo</module>
        <module>sky-server</module>
    </modules>
	
    <!-- 可以在这里统一管理依赖版本 -->
    <properties>
        <mybatis.spring>2.2.0</mybatis.spring>
        <!-- 这指定了lombok的版本 -->
        <lombok>1.18.20</lombok>
        ……
    </properties>
    
    <dependencyManagement>
        <dependencies>
            <!-- 引入lombok -->
            <dependency>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
                <version>${lombok}</version>
            </dependency>
            
            <!-- Spring Boot 示例 -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>3.2.0</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

</project>
```

父模块只用作依赖的版本管理，假如要在子模块中使用相关依赖，我们还是需要在子模块的pom中写依赖的，**但是我们可以节省它的版本不写。**



其他模块的pom写法是类似的，例如sky-common：

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
	
    <!-- 指定父模块 -->
    <parent>
        <groupId>com.sky</groupId>
        <artifactId>sky-take-out</artifactId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <artifactId>sky-common</artifactId>
    <packaging>jar</packaging>

    <dependencies>
        <!-- 我在这个模块中引入了lombok且继承了父模块的版本 -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
    </dependencies>
</project>
```

### 2，多环境开发

必须先了解引入项目属性的方式。熟知的可能有properties文件和yml文件引入。

**命令行方式**，也就是项目上线的时候，我们可能会用到这个命令：

```
java -jar (jar包路径) --server.port=9999
```

后面我们增加了--server.port=9999，其实就是更改了默认项目的启动端口。也就是实质上覆盖了内部的属性。原理其实就是通过启动类上的args数组参数获取了这个属性。

**外部配置**。在上线时，把jar包和外部配置文件yml放到同一文件下，就可以让程序利用这个yml文件内部的属性。

还有上线时最常用的方式，**环境变量**

一些敏感的内容，比如当我们有自己的服务器，与服务器进行连接时的一些容器是我们不想暴漏给外部的，比如存储图片的服务器、数据库等等。这些连接可能会有一些密钥，例如aliyunOSS，需要以下四个属性建立连接。

```yaml
  alioss:
    access-key-id: ${sky.alioss.access-key-id}
    access-key-secret: ${sky.alioss.access-key-secret}
    bucket-name: ${sky.alioss.bucket-name}
    endpoint: ${sky.alioss.endpoint}
```

但无论放在打包好的项目里，还是更暴露从服务器内部文件或是外部配置获取，都是不安全的。因此我们应该把这种敏感的信息放在环境变量里。

例如我们想

```yaml
# application.yml
server:
  port: 8080

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/test
    username: root
    password: 123456
```

对应地这样写

```bash
export SERVER_PORT=9090
export SPRING_DATASOURCE_URL=jdbc:mysql://prodhost:3306/proddb
export SPRING_DATASOURCE_USERNAME=admin
export SPRING_DATASOURCE_PASSWORD=secret
```

就可以使用了

从外部配置yml文件我们可以得出一个技巧：

**我们可以用多个yml文件在不同的环境下进行项目管理。比如：项目总yml、开发时yml、测试时yml以及正式上线时yml。**

为每个环境去配置yml文件就可以了，使用Profiles属性在父yml中：

```yaml
spring:
  profiles:
    active: dev
  datasource:
    druid:
      driver-class-name: ${sky.datasource.driver-class-name}
      url: ${sky.datasource.url}
      username: ${sky.datasource.username}
      password: ${sky.datasource.password}
server:
  port: ${sky.port}
```

开发环境的yml 文件名按照指定的写就是 application-dev.yml :

```yaml
sky:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://43.153.205.189:3306/sky_take_out
    username: remotezht
    password: zht12345678@
    port:8080

```

其他的就可以如法炮制 application-test.yml ：

```yaml
sky:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/sky_take_out
    username: zht
    password: zht12345678@
    port:8081
```

等等



更大型的项目我们甚至可以指定分组，使用Profiles属性以及Group属性在父yml中：

```yaml
spring:
  profiles:
    group: 
    	"dev":devServer,devDB,devSelf
    	"test":testServer,testDB,testSelf
    active: dev
    datasource:
        druid:
          driver-class-name: ${sky.datasource.driver-class-name}
          url: ${sky.datasource.url}
          username: ${sky.datasource.username}
          password: ${sky.datasource.password}
server:
	port:${sky.port}
	servlet:
		context-path:${sky.context-path}
```

指定两个分组，每个分组包含了三个配置文件，这样就能进一步按职责把配置分割开来。

devServer.yml：

```yaml
sky:
	port:8080
  	context-path:"/aaa"
```

devDB.yml：

```yaml
sky:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/sky_take_out
    username: zht
    password: zht12345678@
```

devSelf：

```yaml
sky:
  jwt:
    # 设置jwt签名加密时使用的秘钥
    admin-secret-key: itcast
    # 设置jwt过期时间
    admin-ttl: 7200000
    # 设置前端传递过来的令牌名称
    admin-token-name: token
    #等等开发环境独有的属性
```

test组的文件也是类似的。

### 3，DTO、VO和传统实体类的区别

实体类通常和数据库一一对应，也就是数据库表结构什么样，它的属性就应该是什么样。

DTO一般用来从前端或者微服务间接收JSON数据格式的对象，因此它不一定对应数据表。比如当我们要分页查询时，前端会返回页码、页大小、模糊查询的字段。这和数据库内部的数据格式一定不一致，因为我们不会特意去存储页大小。然而如果通过参数方式获取，接受的参数又太多，Controller处又不好写，所以我们使用一个DTO对象就完美了。

```java
import lombok.Data;
import java.io.Serializable;

@Data
public class CategoryPageQueryDTO implements Serializable {

    //页码
    private int page;

    //每页记录数
    private int pageSize;

    //分类名称，模糊查询
    private String name;

}

```



VO是用来转门给前端展示数据用的对象，比如当一个属性它的表结构很庞大，属性很多，但是前端未必所有业务都想看到它全部的数据，那么就需要VO。

比如一个菜品实体可能是这样：

```java
package com.sky.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * 菜品
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Dish implements Serializable {

    private static final long serialVersionUID = 1L;

    private Long id;

    //菜品名称
    private String name;

    //菜品分类id
    private Long categoryId;

    //菜品价格
    private BigDecimal price;

    //图片
    private String image;

    //描述信息
    private String description;

    //0 停售 1 起售
    private Integer status;

    private LocalDateTime createTime;

    private LocalDateTime updateTime;

    private Long createUser;

    private Long updateUser;

}

```

但展示时有些数据客户并不关心，比如它的创建时间、创建人、更新人等。所以对应的DishVO可能是这样的

```java
package com.sky.vo;

import com.sky.entity.DishFlavor;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class DishVO implements Serializable {

    private Long id;
    //菜品名称
    private String name;
    //菜品分类id
    private Long categoryId;
    //菜品价格
    private BigDecimal price;
    //图片
    private String image;
    //描述信息
    private String description;
    //0 停售 1 起售
    private Integer status;
    //更新时间
    private LocalDateTime updateTime;
    //分类名称
    private String categoryName;
    //菜品关联的口味
    private List<DishFlavor> flavors = new ArrayList<>();

}

```

总之这三类实体都是POJO类但是应用场景不同而已，我们需要根据情况去设计这些类。

## 二、新工具

1，自动生成文档并有在线调试页面的Swagger，以及Knife4J框架

2，开源JWT项目jjwt（类似的项目很多）

3，pagehelper

4，



## 三、验证用户身份 JWT + ThreadLocal

JWT（**JSON Web Token**）是一种基于 JSON 的开放标准（RFC 7519），用于在客户端和服务端之间安全地传递信息。它本质上是一种 **自包含的令牌（Token）**，可以在不存储会话信息的情况下验证用户身份。

JWT 由三部分组成，每部分用 `.`分隔：

```
header.payload.signature
```

1）头部

头部一般是Base64Url编码后的 令牌名（由用户指定的）+使用的算法，例如：

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

2）负载

由各种各样的**声明（claims）**构成，一般分为三大类：

**Registered Claims**（注册声明）：如 `iss`（发行者）、`exp`（过期时间）、`sub`（主题）、`aud`（受众）等。

**Public Claims**（公共声明）：可自定义，但应避免冲突。

**Private Claims**（私有声明）：应用自定义的业务字段，比如 `userId`、`role`。

比如：



```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true,
  "iat": 1695360000
}
```

虽然负载也被Base64编码，但是并不加密，所以不能存放敏感信息。

3）签名

说白了就是个公式：

```ini
signature = HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
```



所以假如现在有个用户登陆成功了，必然现在有一些关于该用户的数据，例如独一无二的用户id、用户名之类的信息，我们将它们放进负载里，就能利用JWT创建一个**令牌**（token），这样我们就能验证用户的身份。**登陆后把这个令牌返回给前端。**这样做的好处就是代替**session**，降低了服务器的负载。

这之后，每次前端的请求的头部都会有：

```json
“Authorization”: <token>
```

如果这个用户现在登陆了，而我们又不想每次请求都从后端拿这个用户身份，就可以使用JWT保存它的登陆状态。

**但是现在有个问题：**每次向后端发送请求时，服务器实际上都会创建一个新线程去处理，我们不可能在所有方法里或者是pojo类里时时刻刻携带这个头部，也不应该反复地从数据中获得这个头部，这是非常麻烦的。因此我们应该把它放进线程上下文里，也就是---**ThreadLocal**

我们怎么处理这个头部呢，难道每个controller都写一遍吗。所以我们就要用到**拦截器（interceptor）**：

```java
/**
 * jwt令牌校验的拦截器
 */
@Component
@Slf4j
public class JwtTokenAdminInterceptor implements HandlerInterceptor {
	
    //jwt配置实体类
    @Autowired
    private JwtProperties jwtProperties;
	
    //拦截处理
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //判断当前拦截到的是Controller的方法还是其他资源
        if (!(handler instanceof HandlerMethod)) {
            //当前拦截到的不是动态方法，直接放行
            return true;
        }

        //1、从请求头中获取令牌
        String token = request.getHeader(jwtProperties.getAdminTokenName());

        //2、校验令牌
        try {
            log.info("jwt校验:{}", token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
            log.info("当前员工id：", empId);
            //存在ThreadLocal里
            BaseContext.setCurrentId(empId);
            //3、通过，放行
            return true;
        } catch (Exception ex) {
            //4、不通过，响应401状态码
            response.setStatus(401);
            return false;
        }
    }
    //释放内存
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        BaseContext.removeCurrentId();
        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);
    }
}

```

对应的配置实体类JwtProperties：

```java


@Component
@ConfigurationProperties(prefix = "sky.jwt")
@Data
public class JwtProperties {

    /**
     * 管理端员工生成jwt令牌相关配置
     */
    private String adminSecretKey;
    private long adminTtl;
    private String adminTokenName;

    /**
     * 用户端微信用户生成jwt令牌相关配置
     */
    private String userSecretKey;
    private long userTtl;
    private String userTokenName;

}

```

从注解中看到，该类首先是自动注入产生的Bean对象，用lombok的@Data注解自动生成了一系列方法（形成POJO类），并且指定了其属性值在yml配置文件的sky.jwt之中，这就是下一部分要介绍的内容。

BaseContext内部：

```java
public class BaseContext {

    public static ThreadLocal<Long> threadLocal = new ThreadLocal<>();

    public static void setCurrentId(Long id) {
        threadLocal.set(id);
    }

    public static Long getCurrentId() {
        return threadLocal.get();
    }

    public static void removeCurrentId() {
        threadLocal.remove();
    }
}
```

这样每次我们在业务层里，想要利用ThreadLocal和JWT填充属性就可以直接：

```java
employee.setUpdateUser(BaseContext.getCurrentId());
```



## 四、AOP编写

### 1，业务描述和示例代码

| **序号** | **字段名**  | **含义** | **数据类型** | **操作类型**   |
| -------- | ----------- | -------- | ------------ | -------------- |
| 1        | create_time | 创建时间 | datetime     | insert         |
| 2        | create_user | 创建人id | bigint       | insert         |
| 3        | update_time | 修改时间 | datetime     | insert、update |
| 4        | update_user | 修改人id | bigint       | insert、update |

每次涉及到修改和新增，都会对这几个属性进行操作，写很多重复的代码，这时就可以用AOP。

目的是，在Mapper层处，检测出使用Update或是Insert SQL语句的方法，然后针对性地对它们进行以上这些字段填充，从而免去在Service层处写些重复代码。

这时候需要自定义注解，因为Mapper层全是接口。

流程如下：

① 自定义注解 AutoFill，用于标识需要进行公共字段自动填充的方法；

```java
package com.sky.annotation;

import com.sky.enumeration.OperationType;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 自定义注解以填充字段。
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AutoFill {
    //数据库操作类型
    OperationType value();

}

```

② 自定义切面类 AutoFillAspect，统一拦截加入了 AutoFill 注解的方法，通过反射为公共字段赋值；

```java
package com.sky.aspect;

import com.sky.annotation.AutoFill;
import com.sky.constant.AutoFillConstant;
import com.sky.context.BaseContext;
import com.sky.enumeration.OperationType;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.time.LocalDateTime;

@Aspect
@Component
@Slf4j
public class AutoFillAspect {
    /**
     * 对哪些类的哪些方法进行自动填充
     */
    @Pointcut("execution(* com.sky.mapper.*.*(..)) && @annotation(com.sky.annotation.AutoFill)")
    public void autoFillPointCut() {

    }

    /**
     * 自动填充创建和修改的时间和用户
     * @param joinPoint
     */

    @Before("autoFillPointCut()")
    public void autoFillBefore(JoinPoint joinPoint) {
        log.info("开始自动填充");
        //获取方法签名
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        //获取注解对象
        AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class);
        //从注解对象的value来看做的到底是Insert操作还是Update操作
        OperationType operationType = autoFill.value();

        //获取方法的参数
        Object[] args = joinPoint.getArgs();
        if(args == null || args.length == 0) {
            return;
        }

        Object arg = args[0];
        LocalDateTime now = LocalDateTime.now();
        Long currentId = BaseContext.getCurrentId();

        if(operationType == OperationType.INSERT) {
            //创建对象
            try {
                Method setCreateTime = arg.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME,LocalDateTime.class);
                Method setCreateUser = arg.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER,Long.class);
                Method setUpdateTime = arg.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME,LocalDateTime.class);
                Method setUpdateUser = arg.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER,Long.class);

                setCreateTime.invoke(arg,now);
                setCreateUser.invoke(arg,currentId);
                setUpdateTime.invoke(arg,now);
                setUpdateUser.invoke(arg,currentId);
            } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
                throw new RuntimeException(e);
            }
        }else if(operationType == OperationType.UPDATE) {
            //更新对象

            try {
                Method setUpdateTime = arg.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME,LocalDateTime.class);
                Method setUpdateUser = arg.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);
                setUpdateTime.invoke(arg,now);
                setUpdateUser.invoke(arg,currentId);
            } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
                throw new RuntimeException(e);
            }

        }
    }
}

```

③ 在 Mapper 的方法上加入 AutoFill 注解，例如EmployeeMapper里的update和Insert方法。

```java
package com.sky.mapper;

import com.github.pagehelper.Page;
import com.sky.annotation.AutoFill;
import com.sky.dto.EmployeePageQueryDTO;
import com.sky.entity.Employee;
import com.sky.enumeration.OperationType;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

@Mapper
public interface EmployeeMapper {

    /**
     * 根据用户名查询员工
     * @param username
     * @return
     */
    @Select("select * from employee where username = #{username}")
    Employee getByUsername(String username);

    @Insert("insert into employee(name,username,password,phone,sex,id_number,status,create_time,update_time,create_user,update_user)" +
            "values (#{name},#{username},#{password},#{phone},#{sex},#{idNumber},#{status},#{createTime},#{updateTime},#{createUser},#{updateUser})")
    @AutoFill(value = OperationType.INSERT)
    void insert(Employee employee);

    /**
     * 分页查询
     * @param employeePageQueryDTO
     * @return
     */
    Page<Employee> pageQuery(EmployeePageQueryDTO employeePageQueryDTO);

    /**
     * 根据主键动态修改员工信息
     * @param employee
     */
    @AutoFill(value = OperationType.UPDATE)
    void update(Employee employee);

    /**
     * 根据id查员工信息
     * @param id
     * @return
     */
    @Select("select * from employee where id = #{id}")
    Employee getById(Long id);
}

```

借这个例子，来了解AOP的开发流程。

先来看看AOP的相关术语：

| 名称                    | 作用                                                     |
| ----------------------- | -------------------------------------------------------- |
| **Aspect（切面）**      | 一个增强功能模块，这里就是 `AutoFillAspect`              |
| **Advice（通知）**      | 增强的具体逻辑，这里是 `autoFillBefore` 方法             |
| **Pointcut（切入点）**  | 哪些地方需要增强，这里是 `autoFillPointCut`              |
| **JoinPoint（连接点）** | 被增强方法的执行点，这里是 DAO 方法的调用                |
| **Weaving（织入）**     | 把切面逻辑应用到目标方法的过程（编译时、加载时、运行时） |

#### 1）Aspect（切面）

```java
@Aspect //标识这是一个切面类。
@Component //经典交付容器管理
@Slf4j
public class AutoFillAspect { ... }

```

#### 2）Pointcut（切入点）

```java
@Pointcut("execution(* com.sky.mapper.*.*(..)) && @annotation(com.sky.annotation.AutoFill)")
public void autoFillPointCut() {}
```

利用Pointcut注解，指定这些统一操作（通知）应该匹配哪些方法/类，这些方法/类应该有什么特征等等。

`autoFillPointCut()` 方法本身不做任何事情，只是 **定义切入点**。

#### 3）通知（Advice）

```java
@Before("autoFillPointCut()")
public void autoFillBefore(JoinPoint joinPoint) { ... }
```

- `@Before` 表示**前置通知**，即在目标方法执行前执行。
- `joinPoint`：代表目标方法执行点，可以获取方法参数、方法名、目标对象等。



整体流程就是：

- 定义切面类 + 切入点表达式。

- Spring 通过动态代理（JDK （实现了接口）或 CGLIB（未实现接口））在运行时包装目标对象。

- 方法调用经过代理 → 触发通知 → 执行原方法。

- 可以在通知中实现统一增强逻辑（日志、事务、权限、自动填充等）。

  

### 2，编程知识和手法

#### 1）切入点指定使用的空方法

其实这是一种简化编程的手法，它其实是：

```java
@Pointcut("切入点表达式")
public void autoFillPointCut() {}

@Before("autoFillPointCut()")
public void autoFillBefore(JoinPoint joinPoint) { ... }
```

就是给这个复杂的表达式起了个别名，不然比如在每个注解后都写一次这个表达式，非常麻烦。

```java
@Before("execution(* com.sky.mapper.*.*(..)) && @annotation(com.sky.annotation.AutoFill)")
public void autoFillBefore(JoinPoint joinPoint) { ... }
```

#### 2）切入点表达式

```
execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)
```

| 属性                     | 示例                       | 说明             |
| ------------------------ | -------------------------- | ---------------- |
| `modifiers-pattern`      | `public`                   | 方法修饰符，可选 |
| `ret-type-pattern`       | `*` 或 `String`            | 方法返回类型     |
| `declaring-type-pattern` | `com.sky.mapper.*`         | 方法所在类或包   |
| `name-pattern`           | `*` 或 `get*`              | 方法名           |
| `param-pattern`          | `(..)` 或 `(Long, String)` | 参数类型和数量   |
| `throws-pattern`         | `throws Exception`         | 异常类型，可选   |

| 运算符 | 作用               |
| ------ | ------------------ |
| `&&`   | 且，两个条件都满足 |
| `      |                    |
| `!`    | 非，取反条件       |

以上规则还缺少注解：

Spring AOP 提供的属性还有：

- `@within` → 类上有某个注解
- `@target` → 目标对象类型上有某注解
- `@args` → 方法参数类型上有某注解
- `@annotation` → 方法上有某注解

所以这句话

```java
execution(* com.sky.mapper.*.*(..)) && @annotation(com.sky.annotation.AutoFill)
```

就是匹配：

- com.sky.mapper下任意的类的任意方法
- 该方法上必须带有@AutoFill注解

这样的方法。

当这样的方法执行时，才执行指定的方法。

#### 3）通知类型

| 注解              | 执行时机                   | 是否可拿到返回值 | 是否可控制目标方法执行 |
| ----------------- | -------------------------- | ---------------- | ---------------------- |
| `@Before`         | 方法执行前                 | ❌                | ❌                      |
| `@After`          | 方法执行后（无论是否异常） | ❌                | ❌                      |
| `@AfterReturning` | 方法正常返回后             | ✅                | ❌                      |
| `@AfterThrowing`  | 方法抛异常后               | ❌                | ❌                      |
| `@Around`         | 方法执行前后               | ✅                | ✅（可决定是否执行）    |

- 如果只想在执行前做点处理 → `@Before`
- 如果想修改返回值或完全控制方法执行 → `@Around`
- 如果要统一异常处理 → `@AfterThrowing`

#### 4）反射编程手法

通过JoinPoint对象获取方法签名

获取注解上对应的操作类型，到底是Update还是Insert

获取方法的参数（具体的实体类）

反射调用实体类对应的Getter和setter方法，根据操作类型的不同给实体类赋值，比如Update就只需修改更新时间和更新的用户，而Insert就要修改创建和更新的时间和用户。

由于是@Before注解，通知执行完之后才真正的去执行Mapper层的操作，也就是跟数据库交互。



综合以上信息得到流程：

① Spring 扫描到 `@Component` 和 `@Aspect`，将 `AutoFillAspect` 注册为切面。

② Spring 根据 `@Pointcut` 表达式，生成 Mapper 方法的代理对象。

③ 当调用 Mapper 方法时：

- 代理对象先执行 `autoFillBefore`（你的前置通知）。

- 前置通知里：

  1）获取方法签名 `MethodSignature signature = (MethodSignature) joinPoint.getSignature();`

  2）获取注解 `@AutoFill` 和操作类型 `INSERT/UPDATE`

  3）获取方法参数（即实体对象）

  4）通过反射调用实体对象的 `setCreateTime`、`setUpdateUser` 等方法，自动填充时间和用户 ID

④ 通知执行完后，才真正调用 Mapper 方法，将填充后的对象保存到数据库。



至于签名Signature，它包含了很多抽象信息，例如：

| 实现类                 | 描述                            | 场景                                                        |
| ---------------------- | ------------------------------- | ----------------------------------------------------------- |
| `MethodSignature`      | 方法签名                        | `JoinPoint` 对应的方法执行或方法调用                        |
| `ConstructorSignature` | 构造函数签名                    | `JoinPoint` 对应的构造函数执行                              |
| `FieldSignature`       | 字段签名                        | 用于字段访问切点                                            |
| `CodeSignature`        | 包含通用信息的方法/构造函数参数 | 通常是 `MethodSignature` 和 `ConstructorSignature` 的父接口 |

我们能通过这个签名，强制类型转换以得到上述对象，就可以利用它们的属性了。

另：**Spring AOP一般只支持以方法做切点切入**， **并且大部分企业开发只用 Spring AOP**，尤其是常见的事务、日志、权限、缓存等场景；AspectJ 这种能在各种地方切入的框架，主要在特殊框架或工具开发中使用。



## 五、自定义配置类和Spring注解的回顾

其实就是想以Java对象的形式在各处获取配置属性。Springboot提供了两种方法。

### 1，用 `@Component` 或 `@Configuration` 注解，并用 `@ConfigurationProperties` 指定前缀

```java
package com.example.config;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;
import lombok.Data;

@Component
@Data
@ConfigurationProperties(prefix = "myapp") // 对应配置文件里的前缀
public class MyAppProperties {

    private String name;
    private int timeout;
    private boolean enabled;

}

```

这种方法需要属性严格对应yml配置文件中的内容。

使用 `@ConfigurationProperties` 可以直接映射基本类型、对象、List、Map 等，保证类型安全。

### 2，不写@ConfigurationProperties改用@Value一个个对应

```java
package com.example.config;


import org.springframework.stereotype.Component;
import lombok.Data;

@Component
@Data 
public class MyAppProperties {
	@Value("${myapp.name}")
    private String name;
    @Value("${myapp.timeout}")
    private int timeout;
    private boolean enabled;

}
```

特别轻量的写法。

### 3, 不写@ConfigurationProperties

### 通过 `@EnableConfigurationProperties(MyAppProperties.class)` 注册 Bean

也就是

```java
package com.example.config;

import org.springframework.stereotype.Component;
import lombok.Data;

@Component
@Data 
public class MyAppProperties {

    private String name;
    private int timeout;
    private boolean enabled;

}
```

改在启动类上注册，如：

```java
package com.example;

import com.example.config.MyAppProperties;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;

@SpringBootApplication
@EnableConfigurationProperties(MyAppProperties.class)  // 注册 MyAppProperties 为 Bean
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```





当然最终我们都是为了能够@Autowired直接在Service层里直接调用。